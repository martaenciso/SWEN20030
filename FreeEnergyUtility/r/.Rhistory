setwd("C:/Users/Scott/git/SWEN20030/FreeEnergyUtility/r")
?runif
source('C:/Users/Scott/git/SWEN20030/FreeEnergyUtility/r/randomData.r')
View(G)
source('C:/Users/Scott/git/SWEN20030/FreeEnergyUtility/r/randomData.r')
source('C:/Users/Scott/git/SWEN20030/FreeEnergyUtility/r/randomData.r')
source('C:/Users/Scott/git/SWEN20030/FreeEnergyUtility/r/randomData.r')
source('C:/Users/Scott/git/SWEN20030/FreeEnergyUtility/r/randomData.r')
source('C:/Users/Scott/git/SWEN20030/FreeEnergyUtility/r/randomData.r')
source('C:/Users/Scott/git/SWEN20030/FreeEnergyUtility/r/randomData.r')
source('C:/Users/Scott/git/SWEN20030/FreeEnergyUtility/r/randomData.r')
source('~/.active-rstudio-document')
setwd("C:/Users/Scott/git/SWEN20030/FreeEnergyUtility/r")
source('C:/Users/Scott/git/SWEN20030/FreeEnergyUtility/r/randomData.r')
source('C:/Users/Scott/git/SWEN20030/FreeEnergyUtility/r/randomData.r')
filename = "../dat/readfile.dat"
args = scan(file=filename, what=character(),sep="\t", flush=TRUE, quiet=TRUE)
commandArgs = function(trailingOnly) args
# Computes the Gibbs free energy of all given states from a Markov
# transition matrix of probabilities between said states
# Also computes associated error and the most likely folding path
# Scott Gigante, scottgigante@gmail.com, Nov 2014
library(matrixStats)
library(gtools)
library(ggplot2)
## Constants
DEFAULT_TEMP = 300 # temperature if none is given
DEFAULT_FILENAME = "select_above_delete_yes_05.dat"
DEFAULT_ALPHA_SCALE = 10 # number of possible alpha values
TOLERANCE = 0.01 # tolerance for error
K = 0.001987204118 # Boltzmann constant in kcal/mol/K
DAT_PREFIX = "../dat/"
PDF_PREFIX = "../pdf/"
OUTPUT_PREFIX = "free_energy_" # to be prepended to input file name for output
PATH_PREFIX = "path_"
PATH_SUFFIX = "_path.dat" # to be appended to path file
## Define functions
# Use first-order Taylor polynomials to calculate a distribution of the first eigenvector
# Note: n, q, w, T not required, but already calculated so may as well
# w=rowSums(u), w[sapply(w, function(row) sum(row)==0)]=1
# u is a count matrix of transitions from state i to state j
# Returns a vector of the standard deviation of each value in the first eigenvector of T
# Note - some (~1-2%) values return between 4-30 times too large - this method redundant for now
SampleStandardDeviation = function(u,n=nrow(u),samples=1000) {
TSample = array(0,dim=c(n,n,samples))
qSample = matrix(0,nrow=n,ncol=samples)
# Sample each element in T samples times
for (i in 1:n) {
if (sum(u[i,] != 0)) {
TSample[i,,]=t(rdirichlet(samples,u[i,]))
}
}
# calculate eigenvectors
qSample[,k]=abs(Re(eigen(t(TSample[,,k]))$vectors[,1]))
for (k in 1:samples) {
}
# Finally, find standard deviation of each element in this collection of eigenvectors
return(rowSds(qSample))
}
args = commandArgs(trailingOnly=TRUE)
if (length(args) < 1) {
message("Usage: RScript ComputeFreeEnergy.r <inputfiles> <temperature>")
message(paste0("Using default filename: ", DEFAULT_FILENAME))
args=c(DEFAULT_FILENAME)
}
if (suppressWarnings(is.na(as.numeric(args[1])))) {
message("Usage: RScript ComputeFreeEnergy.r <inputfiles> <temperature>")
message(paste0("Using default temperature: ", DEFAULT_TEMP))
args = c(DEFAULT_TEMP, args)
}
if (suppressWarnings(is.na(as.numeric(args[2])))) {
message(paste0("Using default alpha scale: ", DEFAULT_ALPHA_SCALE))
message("Usage: RScript ComputeFreeEnergy.r <inputfiles> <temperature>")
args = c(DEFAULT_ALPHA_SCALE, args)
}
t = as.numeric(args[1])
alpha_scale = as.numeric(args[2])
source('C:/Users/Scott/git/SWEN20030/FreeEnergyUtility/r/FreeEnergyUtility.r')
filename = args[3]
A = read.table(paste0(DAT_PREFIX,filename))
## For especially large data sets, better to remove all zero data first
non_zero = apply(A, 1, function(row) row[3] !=0 )
A=A[non_zero,]
R = sort(unique(c(A[,1],A[,2]))) # record row numbers
## Create count matrix including all possible states in data set
n = length(R)
Z = matrix(0,nrow=n,ncol=n)
rownames(Z)=R
colnames(Z)=R
for (i in 1:nrow(A)) {
Z[match(A[i,1],R),match(A[i,2],R)]=A[i,3]
}
## Remove empty rows
non_zero = apply(Z,1,function(row) sum(row)!=0) | apply(Z,2,function(col) sum(col)!=0)
Z = Z[non_zero,non_zero]
R = R[non_zero]
n=nrow(Z)
# Generate Dirichlet parameters and associated expected probability matrix
alpha = matrix(1,n,n) # using a uniform prior
alpha[apply(Z, 1, function(row) sum(row)==0)] = 0
u = alpha+Z
w = rowSums(u)
w[sapply(w, function(row) sum(row)==0)] = 1
T = u/w
## Find eigenthings. The largest eigenvalue of T must be 1
B = eigen(t(T))
lambda = B$values[1]
# eigenvalues are in descending order; the first one is steady state
if (abs(lambda-1) > TOLERANCE) {
message(sprintf("Note: eigenvalue of q == %f != 1",lambda))
}
q=B$vectors[,1]
stopifnot(Re(q)==q) # probabilities should be real
q = abs(Re(q))
## Create the free energy vector
G = -K*t*log(q/max(q))
R = R[is.finite(G)]
G = G[is.finite(G)]
d = floor(R/alpha_scale)
a = R%%alpha_scale
z_energy = matrix(Inf,nrow=max(d),ncol=alpha_scale) # free energy infinite where inaccessible
z_error = matrix(Inf,nrow=max(d),ncol=alpha_scale)
x = 1:max(d)
y = (0:(alpha_scale-1))/alpha_scale
O_energy = matrix("",nrow=max(d),ncol=alpha_scale)
O_error = matrix("",nrow=max(d),ncol=alpha_scale)
for (i in 1:length(G)) {
z_energy[d[i],a[i]+1]=G[i]
O_energy[d[i],a[i]+1]=sprintf("%f",G[i])
}
## Print to a data file
rownames(O_energy) = x
colnames(O_energy) = y
path = read.table(paste0(DAT_PREFIX,OUTPUT_PREFIX,filename,PATH_SUFFIX))
path_x = c(0:(nrow(path)-1))
path_y = path[,3]
pdf(sprintf("%s%s%s.pdf",PDF_PREFIX,OUTPUT_PREFIX,filename))
filled.contour(x,y,z_energy,main="Free Energy (kcal/mol)", sub=filename,xlab="End-to-End Distance (Ã)",ylab="Alpha Helicity", color.palette=colorRampPalette(c("red","yellow","green","cyan","blue","purple")), nlevels = 100, plot.axes={lines(path[,1],path[,2],type="l",col="purple",lty=1,lwd=3); axis(1); axis(2)})
dev.off()
path = read.table(paste0(DAT_PREFIX,OUTPUT_PREFIX,filename,PATH_SUFFIX))
path_x = c(0:(nrow(path)-1))
path_y = path[,3]
pdf(sprintf("%s%s%s.pdf",PDF_PREFIX,OUTPUT_PREFIX,filename))
filled.contour(x,y,z_energy,main="Free Energy (kcal/mol)", sub=filename,xlab="End-to-End Distance (Ã)",ylab="Alpha Helicity", color.palette=colorRampPalette(c("red","yellow","green","cyan","blue","purple")), nlevels = 100, plot.axes={lines(path[,1],path[,2],type="l",col="black",lty=1,lwd=3); axis(1); axis(2)})
source('C:/Users/Scott/git/SWEN20030/FreeEnergyUtility/r/randomData.r')
source('C:/Users/Scott/git/SWEN20030/FreeEnergyUtility/r/randomData.r')
source('C:/Users/Scott/git/SWEN20030/FreeEnergyUtility/r/randomData.r')
b=c(1:3)
rep(3,b)
rep(b,3)
?rep
rep(b,each=3)
source('C:/Users/Scott/git/SWEN20030/FreeEnergyUtility/r/randomData.r')
source('C:/Users/Scott/git/SWEN20030/FreeEnergyUtility/r/randomData.r')
source('C:/Users/Scott/git/SWEN20030/FreeEnergyUtility/r/randomData.r')
source('C:/Users/Scott/git/SWEN20030/FreeEnergyUtility/r/randomData.r')
?write.table
source('C:/Users/Scott/git/SWEN20030/FreeEnergyUtility/r/randomData.r')
source('C:/Users/Scott/git/SWEN20030/FreeEnergyUtility/r/runFreeEnergyUtility.r')
source('C:/Users/Scott/git/SWEN20030/FreeEnergyUtility/r/randomData.r')
source('C:/Users/Scott/git/SWEN20030/FreeEnergyUtility/r/runFreeEnergyUtility.r')
